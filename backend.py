# -*- coding: utf-8 -*-
"""backend.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1k5E5T1AWLSe6LFACHroDd-RI985Zd3dP
"""

# !pip install flask_cors pyngrok

import requests
import json
from google.colab import userdata
from flask import Flask, request, jsonify
from flask_cors import CORS
import os
import subprocess
import time
import math
import random

# --- Install necessary libraries ---
# This part is for Colab environment setup and should be run once.

# --- Setup ngrok with pyngrok ---
from pyngrok import ngrok, conf

NGROK_AUTH_TOKEN = userdata.get('NGROK_AUTH_TOKEN') # Assuming you've added your ngrok auth token to Colab secrets

if not NGROK_AUTH_TOKEN:
    print("WARNING: ngrok auth token not found in Colab secrets. Please add 'NGROK_AUTH_TOKEN'.")
    print("You can get one from https://dashboard.ngrok.com/get-started/your-authtoken")
    print("Tunnels created without an authtoken will be rate-limited and will expire after a few hours.")
    # Set the auth token for pyngrok configuration
    conf.get_default().auth_token = None # Clear if not found
else:
    conf.get_default().auth_token = NGROK_AUTH_TOKEN

# Connect to ngrok - this will start the ngrok process and tunnel
print("Starting ngrok tunnel via pyngrok...")
try:
    public_url = ngrok.connect(5000).public_url # Tunnel port 5000 (Flask's default)
    print(f"Public ngrok URL: {public_url}/curiosidade?place=Marco%20Zero")
    print(f"New route for coordinates: {public_url}/nearest_curiosity?lat=-8.06&lon=-34.96")
except Exception as e:
    print(f"Error starting ngrok tunnel: {e}")
    public_url = "NGROK_TUNNEL_FAILED"


# --- End ngrok setup ---

# Initialize Flask app
app = Flask(__name__)
CORS(app) # Enable CORS for all origins, allowing frontend access

try:
    API_KEY = userdata.get('GOOGLE_API_KEY') # For Gemini API
    GOOGLE_CSE_API_KEY = userdata.get('GOOGLE_CSE_API_KEY') # For Google Custom Search API
    GOOGLE_CSE_CX = userdata.get('GOOGLE_CSE_CX') # Your Custom Search Engine ID
except userdata.SecretNotFoundError:
    print("Erro: Uma ou mais chaves de API não encontradas nos segredos do Colab.")
    print("Por favor, adicione 'GOOGLE_API_KEY', 'GOOGLE_CSE_API_KEY', e 'GOOGLE_CSE_CX'.")
    API_KEY = None
    GOOGLE_CSE_API_KEY = None
    GOOGLE_CSE_CX = None

# Predefined list of places with their coordinates (image_names are no longer needed here)
PLACES = [
    {"name": "Instituto Brennand", "lat": -8.066005019234353, "lon": -34.96327915767114},
    {"name": "Museu do Estado de Pernambuco", "lat": -8.044956747745111, "lon": -34.902884346566495},
    {"name": "Marco Zero", "lat": -8.0631, "lon": -34.8711},
    {"name": "Paço do Frevo", "lat": -8.0628, "lon": -34.8722},
    {"name": "Embaixada dos Bonecos Gigantes", "lat": -8.0625, "lon": -34.8730}
    # Add more places as needed
]

def haversine_distance(lat1, lon1, lat2, lon2):
    """
    Calculate the distance between two points on Earth using the Haversine formula.
    Args:
        lat1, lon1 (float): Latitude and Longitude of point 1 (in degrees).
        lat2, lon2 (float): Latitude and Longitude of point 2 (in degrees).
    Returns:
        float: Distance in kilometers.
    """
    R = 6371 # Radius of Earth in kilometers

    lat1_rad = math.radians(lat1)
    lon1_rad = math.radians(lon1)
    lat2_rad = math.radians(lat2)
    lon2_rad = math.radians(lon2)

    dlon = lon2_rad - lon1_rad
    dlat = lat2_rad - lat1_rad

    a = math.sin(dlat / 2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2)**2
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))

    distance = R * c
    return distance

def find_nearest_place(input_lat, input_lon):
    """
    Finds the nearest place from the predefined PLACES list to the given input coordinates.
    Args:
        input_lat (float): Latitude of the input location.
        input_lon (float): Longitude of the input location.
    Returns:
        dict: The dictionary of the nearest place, or None if PLACES is empty.
    """
    if not PLACES:
        return None

    nearest_place = None
    min_distance = float('inf') # Initialize with a very large number

    for place in PLACES:
        distance = haversine_distance(input_lat, input_lon, place["lat"], place["lon"])
        if distance < min_distance:
            min_distance = distance
            nearest_place = place

    return nearest_place

def gerar_curiosidade_recife(nome_do_lugar):
    """
    Gera uma curiosidade breve sobre um local em Recife usando a API do Gemini.

    Args:
        nome_do_lugar (str): O nome do local em Recife.

    Returns:
        str: Uma curiosidade breve sobre o local, em português, ou uma mensagem de erro.
    """
    if not API_KEY:
        return "Não foi possível gerar a curiosidade. Chave de API ausente."

    api_url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={API_KEY}"
    prompt = f"Imagine que você é um guia turístico em Recife. Gere uma curiosidade breve e interessante sobre '{nome_do_lugar}' em Recife, como se estivesse mostrando o local para um grupo. A curiosidade deve ser em português."

    payload = {
        "contents": [
            {
                "role": "user",
                "parts": [
                    {"text": prompt}
                ]
            }
        ]
    }

    headers = {
        "Content-Type": "application/json"
    }

    try:
        response = requests.post(api_url, headers=headers, data=json.dumps(payload))
        response.raise_for_status()
        result = response.json()
        print("Result")
        print(result['candidates'][0].get("content").get("parts")[0].get("text"))

        curiosidade = result['candidates'][0].get("content").get("parts")[0].get("text")
        return curiosidade
    except requests.exceptions.RequestException as e:
        return f"Erro ao fazer a requisição à API do Gemini: {e}"
    except json.JSONDecodeError:
        return "Erro ao decodificar a resposta JSON da API."
    except Exception as e:
        return f"Ocorreu um erro inesperado: {e}"

def search_images_for_place(query: str, num_images: int = 10) -> list[str]:
    """
    Searches for images related to a place using Google Custom Search API.
    Args:
        query (str): The search query (e.g., "Instituto Brennand Recife").
        num_images (int): The maximum number of image URLs to return.
    Returns:
        list[str]: A list of image URLs.
    """
    if not GOOGLE_CSE_API_KEY or not GOOGLE_CSE_CX:
        print("WARNING: Google CSE API key or CX not configured. Cannot search for images.")
        return []

    search_url = "https://www.googleapis.com/customsearch/v1"
    params = {
        "q": query,
        "cx": GOOGLE_CSE_CX,
        "key": GOOGLE_CSE_API_KEY,
        "searchType": "image", # Crucial for image search
        "num": 10, # Number of results to return
        "fileType": "jpg", # Filter for image file types
    }

    try:
        response = requests.get(search_url, params=params)
        response.raise_for_status() # Raise an exception for HTTP errors
        data = response.json()

        image_urls = []
        if "items" in data:
            for item in data["items"]:
                if "link" in item:
                    image_urls.append(item["link"])
        return [random.choice(image_urls)]
    except requests.exceptions.RequestException as e:
        print(f"Error during image search API call: {e}")
        return []
    except json.JSONDecodeError:
        print("Error decoding JSON from image search API.")
        return []
    except Exception as e:
        print(f"An unexpected error occurred during image search: {e}")
        return []

# Existing API Endpoint for curiosity by place name
@app.route('/curiosidade', methods=['GET'])
def get_curiosidade():
    nome_do_lugar = request.args.get('place')

    if not nome_do_lugar:
        return jsonify({"error": "Parâmetro 'place' ausente na requisição."}), 400

    curiosidade = gerar_curiosidade_recife(nome_do_lugar)

    return jsonify({"place": nome_do_lugar, "curiosity": curiosidade})

# NEW API Endpoint for curiosity by coordinates
@app.route('/nearest_curiosity', methods=['GET'])
def get_nearest_curiosity():
    try:
        lat = float(request.args.get('lat'))
        lon = float(request.args.get('lon'))
    except (TypeError, ValueError):
        return jsonify({"error": "Parâmetros 'lat' e 'lon' são obrigatórios e devem ser números válidos."}), 400

    nearest_place_data = find_nearest_place(lat, lon)

    if nearest_place_data:
        nome_do_lugar = nearest_place_data["name"]
        curiosidade = gerar_curiosidade_recife(nome_do_lugar)
        image_urls = search_images_for_place(f"{nome_do_lugar} Recife Século XIX") # Search for images
        return jsonify({
            "input_coordinates": {"lat": lat, "lon": lon},
            "nearest_place": nome_do_lugar,
            "curiosity": curiosidade,
            "image_urls": image_urls # Include the list of image URLs in the response
        })
    else:
        return jsonify({"error": "Nenhum lugar predefinido encontrado para calcular a proximidade."}), 404


if __name__ == '__main__':
    print("Flask app running on http://127.0.0.1:5000")
    app.run(port=5000)